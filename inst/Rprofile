#This R profile is used when a cluster does not allow spawning or a job 
#scheduler is required to launch any parallel jobs. Saving this file as 
#.Rprofile in the working directory or root directory. Then run
#mpirun -np [cpu numbers] R --save --q

#Cannot be used as Rprofile.site because it will not work

if (!library(Rmpi,logical.return = TRUE)){
    warning("Rmpi cannot be loaded")
    q(save = "no")
}

options(error=quote(assign(".mpi.err", FALSE, env = .GlobalEnv)))

if (!interactive())
    options(echo=FALSE)

if (mpi.comm.size(0) > 1)
    invisible(mpi.comm.dup(0,1))

if (mpi.comm.rank(0) >0){
    sys.load.image(".RData",TRUE)
    .comm <- 1
    while (1) {
    	try(eval(mpi.bcast.cmd(rank=0,comm=.comm),envir=sys.parent()))
    }
    mpi.barrier(.comm)
    mpi.comm.free(.comm)
    mpi.quit()
}

if (mpi.comm.rank(0) == 0) {
    if (!interactive()){
	mylib <- dirname(.path.package("Rmpi"))
        ver <- package.description("Rmpi", lib = mylib)["Version"]
        vertxt <- paste("\n\tRmpi version:", ver, "\n")
        introtxt <- paste("\tRmpi is an interface (wrapper) to MPI APIs\n",
              "\twith interactive R slave functionalities\n",
              "\tSee `library (help=Rmpi)' for details.\n", sep = "")
        cat(paste(vertxt, introtxt))
        cat("\n")
    }
    if(mpi.comm.size(0) > 1)
     	slave.hostinfo(1)
    else {
	if (!interactive())
  	    mpi.hostinfo(0)
    }
}

.First <- function(){
    if (mpi.comm.size(0) > 1)
    	assign(".comm", 1, .GlobalEnv)
    else
    	assign(".comm", 0, .GlobalEnv)	
}

.Last <- function(){
    if (is.loaded("mpi_initialize")){
        if (mpi.comm.size(1) > 1){
            print("Please use mpi.close.Rslaves() to close slaves")
            mpi.close.Rslaves(comm=1)
	}
    }
    print("Please use mpi.quit() to quit R")
    mpi.quit()
}
